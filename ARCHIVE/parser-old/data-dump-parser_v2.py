# Project Sentinel: TiM781 Log File Parser 
# Harris M 
# October 21, 2019 

# LIBRARIES 
import re

# Log file location 
sample_file = '../sample_logs/Single_11-19-19.log'

# Global array/variable instantiation
raw_objects = [] 
pruned_objects = []
clean_objects = []
parsed_messages = []
garbage_count = 9

command_type = {'73524e': 'Read',
                '73574e': 'Write',
                '734d4e': 'Method',
                '73454e': 'Event',
                '735241': 'Answer',
                '735741': 'Answer',
                '73414e': 'Answer',
                '734541': 'Answer',
                '73534e': 'Answer'}

message_class = {'4c4d447363616e64617461': 'Telegram Data'

                }

telegram_structure = {'Version Number': '',
                      'Device Number': '',
                      'Serial Number': '',
                      'Device Status': '',
                      'Telegram Counter': '',
                      'Scan Counter': '',
                      'Time since start up': '',
                      'Time of transmission': '',
                      'Status of digital inputs': '',
                      'Status of digital outputs': '',
                      'Reserved': '',
                      'Scan Frequency': '',
                      'Measurement Frequency': '',
                      'Amount of encoder': '',
                      'Encoder position': '',
                      'Encoder speed': '',
                      'Amount of 16-bit channels': '',
                      'Content': '',
                      'Scale factor': '',
                      'Scale factor offset': '',
                      'Start angle': '',
                      'Size of single angular step': '',
                      'Amount of data': '',
                      'Data': [],
                      'Amount of 8-bit channels': '',
                      'Position': '',
                      'Name': '',
                      'Comment': '',
                      'Time': '',
                      'Event info': '',
                      'Frame': ''
                      }

# Function: load_file
# Description: Loads a log file generated by the TiM781 sensor
def load_file(file):
    file_length = 0
    try:
        with open(file, "r") as f:
            for line in f:
                raw_objects.append(line)
    except IOError:
        print("Error: Couldn't open the specified file.")

# Function: prune_objects
# Description: Splits the raw data into indices of an array
#              efficiently by using a regular expression
def prune_objects():
    load_file(sample_file)

    for raw_object in raw_objects:
        prune = re.findall('[<0-9a-z>]+', raw_object) # This regular expression isn't perfect, so I account for that in the next for loop
        pruned_objects.append(prune)

    for index in range(len(pruned_objects)):
        if index > 0:
            for i in range(garbage_count):
                arr = pruned_objects[index]
                hold = arr[0]
                arr.remove(hold)

    for index in range(len(pruned_objects)):
        if index > 0:
            raw_string = pruned_objects[index]
            first_replace = raw_string[0].replace('><', ',')
            second_replace = first_replace.replace('<', '')
            third_replace = second_replace.replace('>', '')
            comma_splice = third_replace.split(',')
            size = len(comma_splice)
            idx_list = [idx + 1 for idx, val in enumerate(comma_splice) if val == '20'] 
            res = [comma_splice[i: j] for i, j in zip([0] + idx_list, idx_list + ([size] if idx_list[-1] != size else []))] 
            clean_objects.append(res)

# Function: header determination
# Description: Figures out what kind of header we have 
def header_det(head):
    first_remove = head[1:]
    last_remove = first_remove[:-1]
    header = ''
    for i in range(len(last_remove)):
        header += last_remove[i]
    return header

# Function: message type determination
# Description: Figures out what kind of message we have 
def msg_det(msg):
    first_remove = msg[:-1]
    output = ''
    for i in range(len(first_remove)):
        output += first_remove[i]
    return output

# Function: telegram parser
# Description: Parses the core messages for the telegram
def telegram_parse(data):
    print("New run!")
    track = 0
    for item in data:
        print(item)
        current_message = item[:-1]
        hold = ''
        test = ''
        if track == 0:
            for chunk in current_message:  
                hold += str(type_conv(int(chunk, 16), 'u16'))
                test += chunk
            print(int(test, 16))
            telegram_structure['Version Number'] = hold
        elif track == 1:
            for chunk in current_message:  
                hold += str(type_conv(int(chunk, 16), 'u16'))
            telegram_structure['Device Number'] = hold 
        elif track == 2:
            for chunk in current_message:  
                test += chunk
                hold += str(type_conv(int(chunk, 16), 'u32'))
            telegram_structure['Serial Number'] = hold 
        elif track == 3:
            for chunk in current_message:  
                hold += str(type_conv(int(chunk, 16), 'u8'))
            telegram_structure['Device Status'] = hold 
        elif track == 4:
            for chunk in current_message:  
                hold += str(type_conv(int(chunk, 16), 'u16'))
            telegram_structure['Telegram Counter'] = hold
        elif track == 5:
            for chunk in current_message:  
                hold += str(type_conv(int(chunk, 16), 'u16'))
            telegram_structure['Scan Counter'] = hold
        elif track == 6:
            for chunk in current_message:  
                hold += str(type_conv(int(chunk, 16), 'u32'))
            telegram_structure['Time since start up'] = hold
        elif track == 7:
            for chunk in current_message:  
                hold += str(type_conv(int(chunk, 16), 'u32'))
            telegram_structure['Time of transmission'] = hold
        elif track == 8:
            for chunk in current_message:  
                hold += str(type_conv(int(chunk, 16), 'u8'))
            telegram_structure['Status of digital inputs'] = hold
        elif track == 9:
            for chunk in current_message:  
                hold += str(type_conv(int(chunk, 16), 'u8'))
            telegram_structure['Status of digital outputs'] = hold
        elif track == 10:
            for chunk in current_message:  
                hold += str(type_conv(int(chunk, 16), 'u16'))
            telegram_structure['Reserved'] = hold    
        elif track == 11:
            for chunk in current_message:  
                hold += str(type_conv(int(chunk, 16), 'u16'))
            telegram_structure['Scan Frequency'] = hold    
        elif track == 12:
            for chunk in current_message:  
                hold += str(type_conv(int(chunk, 16), 'u16'))
            telegram_structure['Measurement Frequency'] = hold   
        elif track == 13:
            for chunk in current_message: 
                hold += str(type_conv(int(chunk, 16), 'u16'))
            telegram_structure['Amount of encoder'] = hold
        elif track == 14:
            for chunk in current_message: 
                hold += str(type_conv(int(chunk, 16), 'u16'))
            telegram_structure['Encoder position'] = hold
        elif track == 15:
            for chunk in current_message: 
                hold += str(type_conv(int(chunk, 16), 'u16'))
            telegram_structure['Encoder speed'] = hold
        elif track == 16:
            for chunk in current_message: 
                hold += str(type_conv(int(chunk, 16), 'u16'))
            telegram_structure['Amount of 16-bit channels'] = hold
        elif track == 17:
            for chunk in current_message: 
                hold += str(type_conv(int(chunk, 16), 'u16'))
            telegram_structure['Content'] = hold
        elif track == 18:
            for chunk in current_message: 
                hold += str(type_conv(int(chunk, 16), 'u16'))
            telegram_structure['Scale factor'] = hold
        elif track == 19:
            for chunk in current_message: 
                hold += str(type_conv(int(chunk, 16), 'u16'))
            telegram_structure['Scale factor offset'] = hold
        elif track == 20:
            for chunk in current_message: 
                hold += str(type_conv(int(chunk, 16), 'u16'))
            telegram_structure['Start angle'] = hold
        elif track == 21:
            for chunk in current_message: 
                hold += str(type_conv(int(chunk, 16), 'u16'))
            telegram_structure['Size of single angular step'] = hold
        elif track == 22:
            for chunk in current_message: 
                hold += str(type_conv(int(chunk, 16), 'u16'))
            telegram_structure['Amount of data'] = hold

        track = track + 1
    
    print(telegram_structure)


# Function: type converter
# Description: Converts a number to specified base
def type_conv(num, base):
    initial = int(num)
    if base == 's8':
        conv = (initial + 2**7) % 2**8 - 2**7
    elif base == 'u8':
        conv = initial % 2**8 
    elif base == 's16':
        conv = (initial + 2**15) % 2**16 - 2**15
    elif base == 'u16':
        conv = initial % 2**16 
    elif base == 's32':
        conv = (initial + 2**31) % 2**32 - 2**31
    elif base == 'u32':
        conv = initial % 2**32
    elif base == 's64':
        conv = (initial + 2**63) % 2**64 - 2**63
    elif base == 'u64':
        conv = initial % 2**64
    else:
        return initial
    
    return conv

# Function: parser
# Description: This is the real meat of the parser.
def parser():
    prune_objects()

    temp_count = 0

    for message in clean_objects:
        temp_count = temp_count + 1
        if (temp_count == 4):
            break
        message_header = header_det(message[0])
        message_type = msg_det(message[1])
        if (message_class[message_type] == 'Telegram Data'):
            remain = telegram_parse(message[2:])
        
parser()


