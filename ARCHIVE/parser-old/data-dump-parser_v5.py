# Project Sentinel: TiM781 Log File Parser 
# Harris M 
# November 22, 2019 

# LIBRARIES 
import re

# Log file location 
sample_file = '../sample_logs/Sweep0_11-22-19mod.log'

# Global array/variable instantiation
raw_objects = [] 
pruned_objects = []
clean_objects = []
parsed_messages = []
garbage_count = 9

# Constants and look-up tables as defined by SICK 
angle_step = 10000

command_type = {'73524e': 'Read',
                '73574e': 'Write',
                '734d4e': 'Method',
                '73454e': 'Event',
                '735241': 'Answer',
                '735741': 'Answer',
                '73414e': 'Answer',
                '734541': 'Answer',
                '73534e': 'Answer'}

message_class = {'4c4d447363616e64617461': 'Telegram Data'}

scale_factor = {'3F800000': '1x',
                '40000000': '2x'}

telegram_structure_old = {'Version Number': '',
                      'Device Number': '',
                      'Serial Number': '',
                      'Device Status': '',
                      'Telegram Counter': '',
                      'Scan Counter': '',
                      'Time since start up': '',
                      'Time of transmission': '',
                      'Status of digital inputs': '',
                      'Status of digital outputs': '',
                      'Reserved': '',
                      'Scan Frequency': '',
                      'Measurement Frequency': '',
                      'Amount of encoder': '',
                      'Encoder position': '',
                      'Encoder speed': '',
                      'Amount of 16-bit channels': '',
                      'Content': '',
                      'Scale factor': '',
                      'Scale factor offset': '',
                      'Start angle': '',
                      'Size of single angular step': '',
                      'Amount of data': '',
                      'Data': [],
                      'Amount of 8-bit channels': '',
                      'Position': '',
                      'Name': '',
                      'Comment': '',
                      'Time': '',
                      'Event info': '',
                      'Frame': ''}

device_info = {'Version Number': '',
               'Device Number': '',
               'Serial Number': '',
               'Device Status': '',
               'Telegram Counter': '',
               'Scan Counter': '',
               'Time since start-up': '',
               'Time of transmission': '',
               'Status of digital inputs': '',
               'Status of digital outputs': '',
               'Layer Angle': '',
               'Scan Frequency': '',
               'Measurement Frequency': '',
               'Amount of Encoder': '',
               '16-bit Channels': ''}

telegram_structure = {'Message Count': '',
                      'Scale Factor': '',
                      'Scale Factor Offset': '',
                      'Start Angle': '',
                      'Angular Increment': '', 
                      'Quantity': '',
                      'Measurement': []}

# Function: load_file
# Description: Loads a log file generated by the TiM781 sensor
def load_file(file):
    file_length = 0
    try:
        with open(file, "r") as f:
            for line in f:
                raw_objects.append(line)
    except IOError:
        print("Error: Couldn't open the specified file.")

# Function: prune_objects
# Description: Splits the raw data into indices of an array
#              efficiently by using a regular expression
def prune_objects():
    load_file(sample_file)


    for raw_object in raw_objects:
        prune = re.findall('[<0-9a-z>]+', raw_object) # This regular expression isn't perfect, so I account for that in the next for loop
        pruned_objects.append(prune)

    # for index in range(len(pruned_objects)):
    #     if index < 3:
    #         for i in range(garbage_count):
    #             arr = pruned_objects[index]
    #             hold = arr[0]
    #             arr.remove(hold)

    # counter = 0
    # for message in pruned_objects:
    #     print(message)
    #     if (counter == 2):
    #         break
    #     counter = counter + 1

    for index in range(len(pruned_objects)):
        if index > 0:
            curr = pruned_objects[index]
            if len(curr) > 2:
                first_replace = curr[2].replace('><', ',')
            else:
                first_replace = curr[0].replace('><', ',')
            second_replace = first_replace.replace('<', '')
            third_replace = second_replace.replace('>', '')
            comma_splice = third_replace.split(',')
            size = len(comma_splice)
            idx_list = [idx + 1 for idx, val in enumerate(comma_splice) if val == '20'] 
            res = [comma_splice[i: j] for i, j in zip([0] + idx_list, idx_list + ([size] if idx_list[-1] != size else []))] 
            clean_objects.append(res)

# Function: header determination
# Description: Figures out what kind of header we have 
def header_det(head):
    first_remove = head[1:]
    last_remove = first_remove[:-1]
    header = ''
    for i in range(len(last_remove)):
        header += last_remove[i]
    return header

# Function: message type determination
# Description: Figures out what kind of message we have 
def msg_det(msg):
    first_remove = msg[:-1]
    output = ''
    for i in range(len(first_remove)):
        output += first_remove[i]
    return output

# Function: telegram parser
# Description: Parses the core messages for the telegram
def telegram_parse(data):
    counter = 0
    initial = 0
    loop = 0
    for message in data:
        message = message[:-1]
        if (initial == 0):
            curr = ''
            for nibble in message:
                curr += bytearray.fromhex(nibble).decode()
            device_info['Version Number'] = type_conv(curr, 'u16')
            initial = initial + 1
        elif (initial == 1):
            curr = ''
            for nibble in message:
                curr += bytearray.fromhex(nibble).decode()
            device_info['Device Number'] = type_conv(curr, 'u16')
            initial = initial + 1  
        elif (initial == 2):
            curr = ''
            for nibble in message:
                curr += bytearray.fromhex(nibble).decode()
            device_info['Serial Number'] = type_conv(curr, 'u32')
            initial = initial + 1
        elif (initial == 3):
            initial = initial + 1
        elif (initial == 4):
            curr = ''
            for nibble in message:
                curr += bytearray.fromhex(nibble).decode()
            device_info['Device Status'] = type_conv(curr, 'u8')
            initial = initial + 1
        elif (initial == 5):
            curr = ''
            for nibble in message:
                curr += bytearray.fromhex(nibble).decode()
            device_info['Telegram Counter'] = type_conv(curr, 'u16')
            initial = initial + 1
        elif (initial == 6):
            curr = ''
            for nibble in message:
                curr += bytearray.fromhex(nibble).decode()
            device_info['Scan Counter'] = type_conv(curr, 'u16')
            initial = initial + 1
        elif (initial == 7):
            curr = ''
            for nibble in message:
                curr += bytearray.fromhex(nibble).decode()
            device_info['Time since start-up'] = type_conv(curr, 'u32') * 10**(-6)
            initial = initial + 1
        elif (initial == 8):
            curr = ''
            for nibble in message:
                curr += bytearray.fromhex(nibble).decode()
            device_info['Time of transmission'] = type_conv(curr, 'u32') * 10**(-6)
            initial = initial + 1
        elif (initial == 9):
            curr = ''
            for nibble in message:
                curr += bytearray.fromhex(nibble).decode()
            device_info['Status of digital inputs'] = type_conv(curr, 'u8')
            initial = initial + 1
        elif (initial == 10):
            initial = initial + 1
        elif (initial == 11):
            initial = initial + 1
        elif (initial == 12):
            curr = ''
            for nibble in message:
                curr += bytearray.fromhex(nibble).decode()
            device_info['Status of digital outputs'] = type_conv(curr, 'u8')
            initial = initial + 1
        elif (initial == 13):
            curr = ''
            for nibble in message:
                curr += bytearray.fromhex(nibble).decode()
            device_info['Layer Angle'] = type_conv(curr, 'u16')
            initial = initial + 1
        elif (initial == 14):
            curr = ''
            for nibble in message:
                curr += bytearray.fromhex(nibble).decode()
            device_info['Scan Frequency'] = type_conv(curr, 'u32')  
            initial = initial + 1
        elif (initial == 15):
            curr = ''
            for nibble in message:
                curr += bytearray.fromhex(nibble).decode()
            device_info['Measurement Frequency'] = type_conv(curr, 'u32') 
            initial = initial + 1
        elif (initial == 16):
            curr = ''
            for nibble in message:
                curr += bytearray.fromhex(nibble).decode()
            device_info['Amount of Encoder'] = type_conv(curr, 'u32') 
            initial = initial + 1
        elif (initial == 17):
            curr = ''
            for nibble in message:
                curr += bytearray.fromhex(nibble).decode()
            device_info['16-bit Channels'] = type_conv(curr, 'u32') 
            initial = initial + 1
        elif (message[0] == '44' and message[1] == '49' and message[2] == '53' and message[3] == '54'):
            telegram_structure['Message Count'] = bytearray.fromhex(message[4]).decode()
            counter = counter + 1
        elif (counter == 1):
            curr = ''
            for nibble in message:
                curr += bytearray.fromhex(nibble).decode()
            telegram_structure['Scale Factor'] = scale_factor[curr]
            counter = counter + 1
        elif (counter == 2):
            curr = ''
            for nibble in message:
                curr += bytearray.fromhex(nibble).decode()
            telegram_structure['Scale Factor Offset'] = type_conv(curr, 'u32')
            counter = counter + 1
        elif (counter == 3):
            curr = ''
            for nibble in message:
                curr += bytearray.fromhex(nibble).decode()
            telegram_structure['Start Angle'] = type_conv(curr, 's32') / angle_step
            counter = counter + 1
        elif (counter == 4):
            curr = ''
            for nibble in message:
                curr += bytearray.fromhex(nibble).decode()
            telegram_structure['Angular Increment'] = type_conv(curr, 'u16') / angle_step
            counter = counter + 1
        elif (counter == 5):
            curr = ''
            for nibble in message:
                curr += bytearray.fromhex(nibble).decode()
            telegram_structure['Quantity'] = type_conv(curr, 'u16')
            counter = counter + 1
        else:
            curr = ''
            for nibble in message:
                curr += bytearray.fromhex(nibble).decode()
            telegram_structure['Measurement'].append(type_conv(curr, 'u16'))
            loop = loop + 1
            if (loop == telegram_structure['Quantity']):
                break
    
    return telegram_structure
            
    # print(device_info)
    # print(telegram_structure)
        
# Function: Hex to Ascii converter 
# Description: Converts a hex boi to its ascii equivalent 
def ascii_conv(num):
    return bytearray.fromhex(num).decode()

# Function: type converter
# Description: Converts a number to specified base
def type_conv(num, base):
    initial = int(num, 16)
    if base == 's8':
        conv = (initial + 2**7) % 2**8 - 2**7
    elif base == 'u8':
        conv = initial % 2**8 
    elif base == 's16':
        conv = (initial + 2**15) % 2**16 - 2**15
    elif base == 'u16':
        conv = initial % 2**16 
    elif base == 's32':
        conv = (initial + 2**31) % 2**32 - 2**31
    elif base == 'u32':
        conv = initial % 2**32
    elif base == 's64':
        conv = (initial + 2**63) % 2**64 - 2**63
    elif base == 'u64':
        conv = initial % 2**64
    else:
        return initial
    
    return conv

# Function: parser
# Description: This is the real meat of the parser.
def parser():
    prune_objects()

    counter = 0

    output = [{} for i in range(len(clean_objects))]

    for message in clean_objects:
        message_header_init = message[0]
        message_header_init = message_header_init[1:-1]
        message_header = ''

        for nibble in message_header_init:
            message_header += nibble

        message_type_init = message[1]
        message_type_init = message_type_init[:-1]
        message_type = ''

        for nibble in message_type_init:
            message_type += nibble

        remaining = message[2:]
        curr_parse = telegram_parse(remaining)
        output[counter] = curr_parse

        if (counter == 2):
            break

        counter = counter + 1

    with open("output.txt", "w") as f:
        for i in range(len(output)):
            f.write(str(output[i]))

parser()

